package hydra

//package hydra

import (
	// "fmt"

	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/netm4ul/netm4ul/core/database"
	mgo "gopkg.in/mgo.v2"

	"github.com/BurntSushi/toml"

	"github.com/netm4ul/netm4ul/modules"
)

//ConfigToml : configuration model (from the toml file)
type ConfigToml struct {
}

// hydra "class"
type Hydra struct {
	Config ConfigToml
}

// Name : name getter
func (H *Hydra) Name() string {
	return "hydra"
}

// Author : Author getter
func (H *Hydra) Version() string {
	return "0.1"
}

// Version : Version getter
func (H *Hydra) Author() string {
	return "pruno"
}

// DependsOn : Generate the dependancies requirements
func (H *Hydra) DependsOn() []modules.Condition {
	var _ modules.Condition
	return []modules.Condition{}
}

// Run : Main function of the module
func (H *Hydra) Run(opt2 []string) (modules.Result, error) {
	H.ParseConfig()
	fmt.Println(&H.Config)
	var opt []string

	// Fast scan option : -F
	if H.Config.FastScan {
		opt = append(opt, "-F")
	}

	// Consider all hosts as up : -Pn
	if H.Config.NoPing {
		opt = append(opt, "-Pn")
	}

	// Ping scan option : -sP
	if H.Config.Ping {
		opt = append(opt, "-sP")
	}

	// UDP ports option : -sU
	if H.Config.Udp {
		opt = append(opt, "-sU")
	}

	// Port range option : -p- for all ports, -p x-y for specific range, nothing for default
	log.Println(H.Config.PortRange)
	if H.Config.PortRange != "Null" {
		opt = append(opt, "-p"+H.Config.PortRange)
	} else if H.Config.PortRange == "-" {
		opt = append(opt, "-p-")
	}

	// Stealth mode
	if H.Config.Stealth {
		opt = append(opt, "-sC")
	}

	// Service detection : -sV
	if H.Config.Services {
		opt = append(opt, "-sV")
	}

	// OS detection : -O
	if H.Config.OS {
		opt = append(opt, "-O")
	}

	// Verbose mode : -v
	if H.Config.Verbose {
		opt = append(opt, "-v")
	}

	// All options mode
	if H.Config.AllOptions {
		opt = append(opt, "-A")
	}

	// TODO : change it for per target option ?
	// filename := opt2[len(opt2)-1] + ".xml"
	filename := "127.0.0.1.xml"
	opt = append(opt, "-oX", filename)

	// TODO : change it for Run argument, will be passed as an option : ./netm4ul 127.0.0.1

	opt = append(opt, opt2...)

	fmt.Println(opt)
	cmd := exec.Command("/usr/bin/hydra", opt...)
	fmt.Println("My cmd:", cmd)
	execErr := cmd.Run()
	if execErr != nil {
		log.Fatal(execErr)
	}
	var err error
	H.Result, err = ioutil.ReadFile(filename)
	if err != nil {
		log.Fatal("Error 2 : ", err)
	}
	H.hydrarun, err = Parse(H.Result)
	return modules.Result{Data: H.hydrarun, Timestamp: time.Now(), Module: H.Name()}, err
}

// HandleMQ : Recv data from the MQ
func (H *Hydra) HandleMQ() error {
	return nil
}

// SendMQ : Send data to the MQ
func (H *Hydra) SendMQ(data []byte) error {
	return nil
}

// ParseConfig : Load the config from the config folder
func (H *Hydra) ParseConfig() error {
	ex, err := os.Executable()
	if err != nil {
		panic(err)
	}

	exPath := filepath.Dir(ex)
	configPath := filepath.Join(exPath, "config", "hydra.conf")
	_, err = toml.DecodeFile(configPath, &H.Config)

	if err != nil {
		log.Fatal("Error !", err)
		return err
	}

	return nil
}

// WriteDb : Save data
func (H *Hydra) WriteDb(result modules.Result, mgoSession *mgo.Session, projectName string) error {
	log.Println("Write to the database.")
	// var data hydraRun
	result.Data = result.Data.(hydraRun)
	// fmt.Printf("============================%+v", result.Data)
	//save raw data
	raw := bsoH.M{projectName + ".results." + result.Module: result}
	database.UpsertRawData(mgoSession, projectName, raw)

	//save data in projects

	return nil
}
